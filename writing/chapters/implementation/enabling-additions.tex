This section analyzes the specific additions required to enable predictive auto-scaling.
The changes are broken into four groups: Recording Pod Initialization Time,
Storing Previous CPU Utilizations, Autoscaling Predictively, and Enabling
Predictive Autoscaling. The first two groups do not directly relate to
predictive auto-scaling, but rather are the scaffolding that make predictive
auto-scaling possible. The third group, Autoscaling Predictively, builds upon
the first two sections in implementing an alternative control flow, which when
enabled, causes the auto-scaler to operate predictively instead of reactively.
The last group of changes discusses how to turn on this alternative control
flow, thus enabling predictive auto-scaling. While breaking this thesis' code
into discrete compartments is in part just a reflection of proper software design,
it is also done to work within the framework of making open-source contributions
to Kubernetes. Kubernetes prefers small, self-contained pull requests, which can
be added without introducing breaking changes. Implementing the sections sequentially ensures
we never submit code which will not run or build.

\subsection{Recording Pod Initialization Time}

\input{chapters/implementation/enabling-additions/recording-pod-initialization-time}

\subsection{Storing Previous CPU Utilizations}

\input{chapters/implementation/enabling-additions/storing-previous-cpu-utilizations}

\subsection{Autoscaling Predictively}
\label{autoscaling-predictively}

\input{chapters/implementation/enabling-additions/autoscaling-predictively}

\subsection{Enabling Predictive Autoscaling}

\input{chapters/implementation/enabling-additions/enabling-predictive-autoscaling}
