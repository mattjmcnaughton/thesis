This section analyzes the specific additions enabling predictive auto-scaling.
The changes are broken intro four groups: Recording Pod Initialization Time,
Storing Previous CPU Utilizations, Autoscaling Predictively, and Enabling
Predictive Autoscaling. The first two groups do not directly relate to
predictive auto-scaling, but rather are the scaffolding that make predictive
auto-scaling possible. The third group, Autoscaling Predictively, builds upon
the first two sections in implementing an alternative control flow, which when
enabled, causes the auto-scaler to operate predictively instead of reactively.
The last group of changes discusses how to turn on this alternative control
flow, and thus enable predictive auto-scaling. While breaking this thesis' code
into discrete compartments is in part just a reflection proper software design,
it is also done to work within the framework of making open-source contributes
to Kubernetes. Kubernetes prefers small, self-contained pull requests, which can
be added without introducing breaking changes. Implementing the sections sequentially, ensures
we never submit code which will not run or build.

\subsection{Recording Pod Initialization Time}

\input{chapters/implementation/enabling-additions/recording-pod-initialization-time}

\subsection{Storing Previous CPU Utilizations}

\input{chapters/implementation/enabling-additions/storing-previous-cpu-utilizations}

\subsection{Autoscaling Predictively}

\input{chapters/implementation/enabling-additions/autoscaling-predictively}

\subsection{Enabling Predictive Autoscaling}

\input{chapters/implementation/enabling-additions/enabling-predictive-autoscaling}
